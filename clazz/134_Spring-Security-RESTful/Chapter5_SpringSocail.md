---
typora-root-url: ./
typora-copy-images-to: ./README_images/5
---



[返回](./README.md)

# 第5章 使用 Spring Social 开发第三方登录

> 参考、整理自：
>
> - [九、SpringSocial基本原理 @Tinner丶](https://www.jianshu.com/p/9e3d2980d9de)
> - [SpringSecurity开发基于表单的认证(八) @ 云师兄 ](https://www.jianshu.com/p/9c8d197ccdab)



- 介绍 OAuth 协议 和 Spring Social 的基本原理和核心概念。
- 深入了解 Spring Social 的底层源码实现，以及扩展这些实现来适应不同的服务提供商。
  - 实现 QQ 认证 和 微信认证。
- 介绍 Spring Security 中与 session 管理相关的特性。
  - 如超时处理，并发控制，集群环境等。



## 5.1(5-1).  OAuth 协议 简介

不管是 Spring Social 还是 Spring Security OAuth，这两个框架都是根据 OAuth 协议来提供功能的。为了理解这两个框架的功能，我们需要对 OAuth 协议有一个较全面的理解。

> 1. OAuth 协议要解决的问题
> 2. OAuth 协议中的各种角色
> 3. OAuth 协议的运行流程

### 5.1.1. OAuth 协议 要解决的问题

首先我来举一个例子。

![image-20200226193523418](README_images/5/image-20200226193523418.png)

> 比如说我要开发一个微信美图助手，可以将用户在微信里面的自拍数据进行美化。这件事对于双方系统都是一件有利的事。对于微信来说，我提供这种服务，用户可能就更愿意把自拍放到微信上，而不是放到别的平台上去。而对于我自己的应用，默认的我可以把微信平台上的所有的这些用户都变为我的潜在用户，这比我从0开始一个个地去扩展用户的效率还是成本都好很多，这本身就是一种共赢的事情。

但是问题来了，微信肯定是不会允许我去随便地去获取 微信的 用户信息的。这时我就需要用户的一个授权，用户同意我去读 用户 在微信中的 自拍数据。有了这个授权之后我就可以告诉微信说用户同意了，这个时候微信就会把用户的 自拍数据 开放给我了。那么如何来得到用户的授权呢？我们可能会想到去要用户的微信名和微信密码，先不说安全问题，就算用户给了我微信名和密码，我拿着用户名和密码去微信中读取用户的 自拍数据，也是会存在很大的问题的。

> ​	问题1：***应用可以访问用户在微信上的所有数据***。因为如果用户把密码给我，我登录微信上之后我想看什么 看什么 ，比如说自己的通讯录好友，朋友圈等信息，并不只是 自拍数据。
> ​	问题2：***用户只有修改密码，才能收回授权***。因为我知道用户名密码了，但是用户并不能控制我到底能用多久，只要用户不更改密码我可以一直使用这个微信账号，但是用户一旦改了密码，其他的第三方应用也用不了了，而且下次再授权还是需要告诉我用户名密码。
> ​	问题3：***密码泄露的可能性大大提高***。如果用这种方式授权，就比如说我只是用户授权的其中之一的服务商，可能对于其他功能还会有很多授权，那么如果其中一个服务商出现了安全问题，将密码泄露了，那么可能用户的数据就泄露了，密码泄露的可能性就会大大提高。

那么为了解决这些问题，**OAuth 协议** 就诞生了，它出现的意义就在于，在用户给服务商授权的时候并不用给我用户名密码，而是可以交给我一个令牌（Token），我再去访问微信上 用户的 自拍数据 的时候 ， 我就不需要 用户的 用户名和密码了，而是用 用户的 令牌 去进行访问。有了这个机制，上述三个问题就会迎刃而解了。

> 首先， 在令牌上写着，你只能访问 用户的 自拍数据。你就没办法访问 用户 在微信上 其他的 数据 了。
>
> 第二， 令牌上会有一个有效期。比如 令牌上写着 这个令牌只能用一个月，那么 一个月 以后就再也不能访问 用户的 自拍数据 了。
>
> 最后，微信 根本就没有把密码给 我们的 美图助手 应用，而是给了它一个 令牌，所以也不会存在 用户密码泄露 的问题。

### 5.1.2. OAuth 协议 中的 各种角色

1. <span style="color:green">**服务提供商**（**Provider**）</span>

   **它用来提供 令牌**。因为之前说了 OAuth 协议 是基于 **令牌（Token）**的，这个令牌总不能让用户写个纸条给我，它本身就是一个电子化的东西。那么谁提供这个令牌，谁就是这个提供商，在我上边的例子中，主要是微信提供这个令牌，那么微信就是这个服务提供商。

   - <span style="color:green">(4) **认证服务器**（**Authenrization Serve**r）</span>

     它的作用是 **认证 用户的 身份 并且 产生 令牌**，<span style="color:green">令牌 是从这个角色中产生出来的。</span>

   - <span style="color:green">(5) **资源服务器**（**Resource Server**）</span>

     这个角色有两个作用：

     - 第一个作用就是 **保存用户的资源**，即 用户的 自拍数据 是保存在 资源服务器 上的。
     - 第二个作用就是 **验证令牌**。最终我们的 第三方应用 发送请求 的时候 是发送到 资源服务器的，发请求的时候 会带着 认证服务器 发给我们的 Token，由 资源服务器 去验证 这个 Token，如果验证过了 就会把 用户的 自拍数据 给第三方应用。

2. <span style="color:green">**资源所有者**（**Resource Owner**）</span>

   资源是指什么？资源就是 用户的 自拍数据。**这些数据所有者是用户，而不是微信，用户只是把这些资源放在了微信上。**那么这里的 资源所有者 就是 用户 。

3. <span style="color:green">**第三方应用**（**Client**）</span>

   第三方应用 也就是 我们例子中的 美图助手，它的目的就是 将 微信用户 转化为 第三方的用户，然后向微信提供服务。

> 认证服务器 和 资源服务器 在 角色上是 2 个，但是在物理上， 他们可以在 同一台 机子上。

![image-20200226201852804](README_images/5/image-20200226201852804.png)

### 5.1.3. OAuth 协议 的 运行流程

首先 用户 要访问 第三方应用。

1. 然后 第三方应用 就会 请求 用户 去授权。

   用户 必须要让 第三方应用 有权限 去访问 相应数据 才能 进行服务。

2. 如果 用户 同意授权，那么 第三方应用 就会去访问 服务提供商 的 认证服务器，告诉 认证服务器 用户同意 我访问 微信上的 自拍数据了，你给我一个令牌（申请令牌）。

3. 其次 认证服务器 会去验证 第三方应用 “说的是不是实话”，即 用户 是不是 真的 同意授权了。

4. 如果 验证 通过了， 认证服务器 就会给 第三方应用 发送一个令牌。

5. 第三方应用 拿到了这个令牌之后，它就可以使用 这个令牌 去 资源服务器 中申请 访问资源。

6. 资源服务器 会验证 （由 第三方应用 发出的）申请资源 请求 上 携带的 令牌，确认令牌无误之后，它会同意把 用户的 自拍数据 开放给 第三方应用。

在这几个步骤中，**第二步（用户同意授权）这个是关键**，因为有了这个授权之后，第三方应用 Client 才能去进行下面的一系列操作 （申请令牌、获取资源）。



![流程](README_images/5/image-20200226215552174.png)



### 5.1.4. OAuth 协议 中的 授权模式

在用户授权的时候，可以将授权模式分为以下几种：

> 1. 授权码模式（authorization code）
> 2. 密码模式（resource owner password credentials）
> 3. ~~客户端模式（client credentials）~~
> 4. ~~简化模式（implicit）~~

其中，用的最多的是 **授权码模式（authorization code）和密码模式（resource owner password credentials）**。

~~客户端模式（client credentials）和 简化模式（implicit）~~在实际开发应用过程中会用的比较少， 这里也不会涉及。



其中特别常见、特别主流、特别安全的一种授权模式，就是授权码模式（authorization code），下面我来详细介绍一下这种授权模式。

### 5.1.5. 授权码模式 简介

授权码模式 是四种授权模式中 <span style="color:green">**功能最完整、流程最严密**</span> 的一种授权模式，不管是微信也好、微博也好，几乎所有的互联网提供商都是采用这种方式来完成授权的。

##### 5.1.5.1. 授权码 模式 授权步骤

用户访问第三方客户端。

1. 如果第三方应用需要用户授权，它会将 用户 导向 认证服务器。
2. **用户 同意 授权 的这个动作 会在 `认证服务器` 上来完成**。
3. 如果 用户 同意 授权，那么 认证服务器 会将 用户 重新引导到 第三方应用上去。
   - 那么导回去 的时候 会导入到 第三方应用 的哪里呢？一般会指向到一个 URL 上去，这个 URL 是 第三方应用 Client 和 服务提供商 事先商量好的。
   - 当 认证服务器 将 用户 导入 第三方应用 的 URL 上去时，会携带一个**授权码**（这个授权码 并不是 第三方应用 需要的 那个令牌（Token））。
4. 第三方应用 在 收到 这个 授权码 之后，会拿着这个 **授权码** 向 认证服务器 上 **申请令牌**，（注意：这一步是在 第三方应用 Client 的 服务器后台 去完成的，对用户是不可见的）。
5. 然后 认证服务器 会核对 第三步给的 那个**授权码 **是不是 之前 给 第三方应用 Client 发过去的，如果确认无误，那么会向 第三方应用 Client **发送令牌（Token）**。

![image-20200226234340073](README_images/5/image-20200226234340073.png)

##### 5.1.5.2. 授权码模式特点

> 在整个过程中，我们了解到，就是因为在授权的时候会产生一个授权码，因此这个方式就叫做授权码模式。

这种模式主要有两个特点：(与其他 3 种 区分开)

1.  <span style="color:green">**用户 同意 授权 的动作是在 认证服务器 上去完成的。**</span>

   - 相比其它三种授权模式中， <span style="color:red">**密码模式和客户端模式，同意授权的动作是在第三方应用上去完成的。**</span>授权之后，第三方应用 Client 去向 认证服务器 申请令牌 的时候 带着一些信息（用户同意 第三方应用 Client 授权）。但是 认证服务器 是没办法确定 用户 是不是真的授权了，有可能这个授权信息是 第三方应用 Client 自己伪造的。
   -  <span style="color:green">**而在 授权码 模式中，“同意授权” 这个动作是在 认证服务器 上去完成的**</span>，所以 认证服务器 可以明确的 知道 用户 确实同意了 授权。

2.  <span style="color:green">**Client 换取令牌 的方式**。</span>

   第三方应用 Client 在整个申请 令牌（Token）的过程中向认证服务器进行了两个请求，第一个是拿到 授权码，第二次请求是拿着 授权码 去换取 真正的 令牌（Token）。

   - 也就是说在这个模式下 要求 第三方应用 必须要有一个服务器，并不是直接返回到 浏览器上，认证服务器 将 令牌 是发给 第三方应用 的 服务器的，安全性会更高。
   - 有些网站只有一些静态页面，没有服务器。这种情况下，它们可能会 用  简化模式（implicit），从 认证服务器 到 第三方 的时候，直接返回的 令牌。然后在第三方 页面上 用 脚本去读取。换句话说，简化模式（implicit）下，你从 浏览器 中就可以直接拿到令牌。

就是因为这两个特点，决定了 **授权码模式** 是 <span style="color:green">**功能最完整、流程最严密**</span> 的一种授权模式，也是现今 第三方应用服务商 最常用的 授权模式。



## 5.2(5-2). Spring Social 简介



> 前面 我们了解到 **OAuth 协议 其实是一个 授权协议**，其目的是 让用户 在不将 服务提供商 的用户名密码 提供给 第三方应用 的情况下，让 第三方应用 有权限访问 用户 存在 服务提供商 上的资源。



**那么 OAuth 协议 跟我们要实现的 第三方登陆 （QQ登录、微信登录等）是什么关系呢？**

*在前面的例子中，走完 授权协议，拿到令牌之后，说的场景是 拿用户的 自拍数据。* 

但是如果我们不去拿 用户的 自拍数据，而是拿 用户的 基本信息（比如 昵称、头像）。根据 用户 基本信息 构建 Authentivcation 并放入 SecurityContext 中去。

- 当我们往 SecurityContext 放入一个 经过验证的 Authentivcation 实例的时候，对于 Spring Security 来说，就是 登陆成功了。
- 如果我们 引导 用户 走完 下面的整个流程 ，实际上就是 拿 用户 在 服务提供商 上边的用户基本信息 登陆了 我们的 第三方应用。这个就是 第三方登录 实现的 基本原理和流程。

![第三方登录 的基本原理和流程](README_images/5/image-20200227112338834.png"第三方登录的 基本原理和流程")



### 5.2.1. Spring Socail 核心功能

> **Spring Social 的核心功能就是 封装 并实现了整个 授权流程。** 


那么 Spring Social 在这一过程中做了什么事情呢？

**Spring Social 就是将这一整个 流程 封装起来 并且实现了。**

- 它把 上面 整个流程 封装到了 `SocialAuthenticationFilter` 的过滤器中，然后把这个过滤器加入到了 Spring Security 的过滤器链上。当访问请求的时候，SocialAuthenticationFilter 会将请求拦截下来，然后将整个流程走完。实际上 就相当于 实现了 第三方登录。

![image-20200227113637177](README_images/5/image-20200227113637177.png)



### 5.2.2. Spring Social 接口说明

> Spring Social 是如何将上面的 流程 封装到 特定的接口和类中去的？以及这些接口和类的调用关系。

![image-20200227234552236](README_images/5/image-20200227234552236.png)

#### 服务提供商相关

在整个流程上面，从第一步到第六步，都是需要跟 服务提供商 打交道的。

所以它的 **第一个接口叫--`ServiceProvider`**，它实际上就是 服务提供商 的一个抽象。

针对每一个 服务提供商（QQ、微信），都需要一个 ServiceProvider 接口的一个实现。Spring Social 提供了一个**`AbstractOauth2ServiceProvider`** 抽象类，实现了一些共有的东西，如果要自己写，只需要 继承 这个类 实现其中的 方法即可。

> 国内因为用 OAuth 协议比较晚，基本是用的都是 OAuth2 协议。

回过头来再看整个流程：

- ①第一步到第五步发放令牌其实是一个标准的流程。
- ②到了第六步（获取用户信息）的时候其实就是一个 个性化的实现，因为每一个 服务提供商 返回的用户信息的 数据结构 定义 都不一样。

针对①和②，SpringSocial 提供了两个接口：

- `Oauth2Operation`（封装第一步到第五步）。

  Spring 提供了一个默认的实现叫`Oauth2Template` ， 这个类会帮助我们去完成 Oauth 协议 的执行流程。

- `API`（个性化第六步），实际上没有一个明确的接口，因为每一个 服务提供商 对于用户基本信息的调用 都是有区别的。这里我们需要自己写一个接口来封装 第六步 获取用户信息 的行为。

  Spring Social 其实也提供了一个抽象类叫`AbstractOauth2ApiBinding` 帮助我们快速开发 第六步 的实现。

#### 第三方应用内部

到了第七步 实际上就跟 服务提供商 没有任何关系了。都是在 第三方应用Client 内部 去完成的。

- 第一个接口是 `Connection`，Spring Social 提供的实现类叫 `OAuth2Connection`。**其作用是 封装 前六步执行完毕之后 获取到的 用户信息**。

- `Connection` 是由 `ConnectionFactory` 工厂类 创建出来的，用到的类叫`OAuth2ConnectionFactory`。

  - **这个工厂类的 作用就是 为了创建 `Connection` 对象 来 获取用户信息。**

    但是用户信息是在`ServiceProvider` 中去构建的。**所以在 `OAuth2ConnectionFactory` 中肯定有一个`ServiceProvider` 实例**，即 `ServiceProvider` 被封装起来放到 `ConnectionFactory` 中去，以便去走 第一步到第五步 的流程 。

  - **注意：`Connection` 的对象名和字段名都是 固定的。**



之前说过，每一个 服务提供商 对于 第六步 获取到的 用户信息的 数据结构 都是不一样的，那么**`ConnectionFactory` 是如何做到将 这些 不同 数据结构的 信息 转化成 `Connection` 这样一个标准的数据结构（ 对象名和字段名 都是固定的 对象）的呢？**

- `ConnectionFactory` 有一个 `ApiAdapter` 。 将 不同格式的 用户信息 转化为 固定格式的 `Connection` 对象就是由 **`ApiAdapter` (Api 接口的 实现类)** 来完成。

  - `ApiAdapter` ，顾名思义，就是在 `Api` 和 `Connection` 之间进行一个 适配。

    转化成功之后就将向 `Connection` 中封装进去一个用户信息。



一般情况下，我们 业务系统 的用户 会存到 数据库 的 Table 里面（如 User 表）。

**如果 将 业务系统中的 用户信息 和 服务提供商 的 用户信息 关联到一块呢？**

- 换句话说， 服务提供商 里的 A 用户 登陆，如何知道是 业务系统的 张三 登陆呢？

在 Spring Social 中， **这个对应关系 是存在 数据库中的**。数据库中有一张 **UserConnection 表**，里面有 **业务系统的 userId 以及 服务提供商 的 Connection 之间的 对应关系**。

那么由谁来 操纵 这个 UserConnection  表呢？就是由 **UsersConnectionRepository**存储器 去实现的。在代码中用到的 实现类 叫做 **JdbcUsersConnectionRepository**, 这个类的作用就是 去数据库中 针对 用户 对应关系表 去做一些增删改查的操作。

